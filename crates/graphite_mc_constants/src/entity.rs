// DO NOT MANUALLY EDIT THIS FILE
// This file has been autogenerated by minecraft_constants/build.rs
// Data is provided courtesy of `https://github.com/Minestom/MinestomDataGenerator`

#![allow(warnings, unused, unused_assignments)]

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
#[repr(u8)]
pub enum Entity {
	Allay = 0,
	AreaEffectCloud = 1,
	ArmorStand = 2,
	Arrow = 3,
	Axolotl = 4,
	Bat = 5,
	Bee = 6,
	Blaze = 7,
	BlockDisplay = 8,
	Boat = 9,
	Breeze = 10,
	Camel = 11,
	Cat = 12,
	CaveSpider = 13,
	ChestBoat = 14,
	ChestMinecart = 15,
	Chicken = 16,
	Cod = 17,
	CommandBlockMinecart = 18,
	Cow = 19,
	Creeper = 20,
	Dolphin = 21,
	Donkey = 22,
	DragonFireball = 23,
	Drowned = 24,
	Egg = 25,
	ElderGuardian = 26,
	EndCrystal = 27,
	EnderDragon = 28,
	EnderPearl = 29,
	Enderman = 30,
	Endermite = 31,
	Evoker = 32,
	EvokerFangs = 33,
	ExperienceBottle = 34,
	ExperienceOrb = 35,
	EyeOfEnder = 36,
	FallingBlock = 37,
	FireworkRocket = 38,
	Fox = 39,
	Frog = 40,
	FurnaceMinecart = 41,
	Ghast = 42,
	Giant = 43,
	GlowItemFrame = 44,
	GlowSquid = 45,
	Goat = 46,
	Guardian = 47,
	Hoglin = 48,
	HopperMinecart = 49,
	Horse = 50,
	Husk = 51,
	Illusioner = 52,
	Interaction = 53,
	IronGolem = 54,
	Item = 55,
	ItemDisplay = 56,
	ItemFrame = 57,
	Fireball = 58,
	LeashKnot = 59,
	LightningBolt = 60,
	Llama = 61,
	LlamaSpit = 62,
	MagmaCube = 63,
	Marker = 64,
	Minecart = 65,
	Mooshroom = 66,
	Mule = 67,
	Ocelot = 68,
	Painting = 69,
	Panda = 70,
	Parrot = 71,
	Phantom = 72,
	Pig = 73,
	Piglin = 74,
	PiglinBrute = 75,
	Pillager = 76,
	PolarBear = 77,
	Potion = 78,
	Pufferfish = 79,
	Rabbit = 80,
	Ravager = 81,
	Salmon = 82,
	Sheep = 83,
	Shulker = 84,
	ShulkerBullet = 85,
	Silverfish = 86,
	Skeleton = 87,
	SkeletonHorse = 88,
	Slime = 89,
	SmallFireball = 90,
	Sniffer = 91,
	SnowGolem = 92,
	Snowball = 93,
	SpawnerMinecart = 94,
	SpectralArrow = 95,
	Spider = 96,
	Squid = 97,
	Stray = 98,
	Strider = 99,
	Tadpole = 100,
	TextDisplay = 101,
	Tnt = 102,
	TntMinecart = 103,
	TraderLlama = 104,
	Trident = 105,
	TropicalFish = 106,
	Turtle = 107,
	Vex = 108,
	Villager = 109,
	Vindicator = 110,
	WanderingTrader = 111,
	Warden = 112,
	WindCharge = 113,
	Witch = 114,
	Wither = 115,
	WitherSkeleton = 116,
	WitherSkull = 117,
	Wolf = 118,
	Zoglin = 119,
	Zombie = 120,
	ZombieHorse = 121,
	ZombieVillager = 122,
	ZombifiedPiglin = 123,
	Player = 124,
	FishingBobber = 125,
}

#[derive(Debug, thiserror::Error)]
#[error("Invalid metadata changes")]
pub struct InvalidMetadataChanges;

pub trait Metadata {
    // fn as_any_mut(&mut self) -> &mut dyn std::any::Any;
    fn read_changes(&mut self, bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges>;
    unsafe fn write_changes<'b>(&mut self, bytes: &'b mut [u8]) -> &'b mut [u8];
    fn get_write_size(&self) -> usize;
}

#[derive(Default)]
enum MetadataChanges<const T: usize> {
    #[default]
    NoChanges,
    SingleChange {
        index: usize
    },
    ManyChanges {
        indices: [bool; T]
    }
}

impl<const T: usize> MetadataChanges<T> {
    fn mark_dirty(&mut self, index: usize) {
        match self {
            Self::NoChanges => {
                *self = Self::SingleChange { index }
            },
            Self::SingleChange { index: old_index } => {
                if *old_index != index {
                    let mut indices = [(); T].map(|_| Default::default());
                    indices[*old_index] = true;
                    indices[index] = true;
                    *self = Self::ManyChanges { indices }
                }
            },
            Self::ManyChanges { indices } => {
                indices[index] = true;
            }
        }
    }
}

use graphite_binary::slice_serialization::*;

#[readonly::make]
#[derive(Default)]
pub struct AllayMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub dancing: bool,
	pub can_duplicate: bool,
}

impl AllayMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_dancing(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.dancing = value;
	}
	pub fn set_can_duplicate(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.can_duplicate = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.dancing)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.can_duplicate)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for AllayMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct AreaEffectCloudMetadata {
	changes: MetadataChanges<12>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub radius: f32,
	pub color: i32,
	pub waiting: bool,
	pub particle: (),
}

impl AreaEffectCloudMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_radius(&mut self, value: f32) {
		self.changes.mark_dirty(8);
		self.radius = value;
	}
	pub fn set_color(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.color = value;
	}
	pub fn set_waiting(&mut self, value: bool) {
		self.changes.mark_dirty(10);
		self.waiting = value;
	}
	pub fn set_particle(&mut self, value: ()) {
		self.changes.mark_dirty(11);
		self.particle = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 4,
			9 => 5,
			10 => 1,
			11 => unimplemented!(),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.radius)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.color)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.waiting)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for AreaEffectCloudMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ArmorStandMetadata {
	changes: MetadataChanges<22>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub client_flags: u8,
	pub head_pose: (f32, f32, f32),
	pub body_pose: (f32, f32, f32),
	pub left_arm_pose: (f32, f32, f32),
	pub right_arm_pose: (f32, f32, f32),
	pub left_leg_pose: (f32, f32, f32),
	pub right_leg_pose: (f32, f32, f32),
}

impl ArmorStandMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_client_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.client_flags = value;
	}
	pub fn set_head_pose(&mut self, value: (f32, f32, f32)) {
		self.changes.mark_dirty(16);
		self.head_pose = value;
	}
	pub fn set_body_pose(&mut self, value: (f32, f32, f32)) {
		self.changes.mark_dirty(17);
		self.body_pose = value;
	}
	pub fn set_left_arm_pose(&mut self, value: (f32, f32, f32)) {
		self.changes.mark_dirty(18);
		self.left_arm_pose = value;
	}
	pub fn set_right_arm_pose(&mut self, value: (f32, f32, f32)) {
		self.changes.mark_dirty(19);
		self.right_arm_pose = value;
	}
	pub fn set_left_leg_pose(&mut self, value: (f32, f32, f32)) {
		self.changes.mark_dirty(20);
		self.left_leg_pose = value;
	}
	pub fn set_right_leg_pose(&mut self, value: (f32, f32, f32)) {
		self.changes.mark_dirty(21);
		self.right_leg_pose = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 12,
			17 => 12,
			18 => 12,
			19 => 12,
			20 => 12,
			21 => 12,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.client_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				{
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.head_pose.0);
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.head_pose.1);
            <BigEndian as SliceSerializable<f32>>::write(bytes, self.head_pose.2)
        }
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				{
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.body_pose.0);
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.body_pose.1);
            <BigEndian as SliceSerializable<f32>>::write(bytes, self.body_pose.2)
        }
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				{
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.left_arm_pose.0);
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.left_arm_pose.1);
            <BigEndian as SliceSerializable<f32>>::write(bytes, self.left_arm_pose.2)
        }
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				{
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.right_arm_pose.0);
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.right_arm_pose.1);
            <BigEndian as SliceSerializable<f32>>::write(bytes, self.right_arm_pose.2)
        }
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				{
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.left_leg_pose.0);
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.left_leg_pose.1);
            <BigEndian as SliceSerializable<f32>>::write(bytes, self.left_leg_pose.2)
        }
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				{
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.right_leg_pose.0);
            bytes = <BigEndian as SliceSerializable<f32>>::write(bytes, self.right_leg_pose.1);
            <BigEndian as SliceSerializable<f32>>::write(bytes, self.right_leg_pose.2)
        }
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ArmorStandMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ArrowMetadata {
	changes: MetadataChanges<11>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_flags: u8,
	pub pierce_level: u8,
	pub id_effect_color: i32,
}

impl ArrowMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.id_flags = value;
	}
	pub fn set_pierce_level(&mut self, value: u8) {
		self.changes.mark_dirty(9);
		self.pierce_level = value;
	}
	pub fn set_id_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.id_effect_color = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 1,
			10 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.pierce_level)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_effect_color)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ArrowMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct AxolotlMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub variant: i32,
	pub playing_dead: bool,
	pub from_bucket: bool,
}

impl AxolotlMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_variant(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.variant = value;
	}
	pub fn set_playing_dead(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.playing_dead = value;
	}
	pub fn set_from_bucket(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.from_bucket = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			19 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.variant)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.playing_dead)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.from_bucket)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for AxolotlMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct BatMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub id_flags: u8,
}

impl BatMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.id_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for BatMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct BeeMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub flags: u8,
	pub remaining_anger_time: i32,
}

impl BeeMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.flags = value;
	}
	pub fn set_remaining_anger_time(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.remaining_anger_time = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.remaining_anger_time)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for BeeMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct BlazeMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub flags: u8,
}

impl BlazeMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for BlazeMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct BlockDisplayMetadata {
	changes: MetadataChanges<24>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub transformation_interpolation_start_delta_ticks: i32,
	pub transformation_interpolation_duration: i32,
	pub pos_rot_interpolation_duration: i32,
	pub translation: (),
	pub scale: (),
	pub left_rotation: (),
	pub right_rotation: (),
	pub billboard_render_constraints: u8,
	pub brightness_override: i32,
	pub view_range: f32,
	pub shadow_radius: f32,
	pub shadow_strength: f32,
	pub width: f32,
	pub height: f32,
	pub glow_color_override: i32,
	pub block_state: Option<i32>,
}

impl BlockDisplayMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_transformation_interpolation_start_delta_ticks(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.transformation_interpolation_start_delta_ticks = value;
	}
	pub fn set_transformation_interpolation_duration(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.transformation_interpolation_duration = value;
	}
	pub fn set_pos_rot_interpolation_duration(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.pos_rot_interpolation_duration = value;
	}
	pub fn set_translation(&mut self, value: ()) {
		self.changes.mark_dirty(11);
		self.translation = value;
	}
	pub fn set_scale(&mut self, value: ()) {
		self.changes.mark_dirty(12);
		self.scale = value;
	}
	pub fn set_left_rotation(&mut self, value: ()) {
		self.changes.mark_dirty(13);
		self.left_rotation = value;
	}
	pub fn set_right_rotation(&mut self, value: ()) {
		self.changes.mark_dirty(14);
		self.right_rotation = value;
	}
	pub fn set_billboard_render_constraints(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.billboard_render_constraints = value;
	}
	pub fn set_brightness_override(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.brightness_override = value;
	}
	pub fn set_view_range(&mut self, value: f32) {
		self.changes.mark_dirty(17);
		self.view_range = value;
	}
	pub fn set_shadow_radius(&mut self, value: f32) {
		self.changes.mark_dirty(18);
		self.shadow_radius = value;
	}
	pub fn set_shadow_strength(&mut self, value: f32) {
		self.changes.mark_dirty(19);
		self.shadow_strength = value;
	}
	pub fn set_width(&mut self, value: f32) {
		self.changes.mark_dirty(20);
		self.width = value;
	}
	pub fn set_height(&mut self, value: f32) {
		self.changes.mark_dirty(21);
		self.height = value;
	}
	pub fn set_glow_color_override(&mut self, value: i32) {
		self.changes.mark_dirty(22);
		self.glow_color_override = value;
	}
	pub fn set_block_state(&mut self, value: Option<i32>) {
		self.changes.mark_dirty(23);
		self.block_state = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 5,
			11 => unimplemented!(),
			12 => unimplemented!(),
			13 => unimplemented!(),
			14 => unimplemented!(),
			15 => 1,
			16 => 5,
			17 => 4,
			18 => 4,
			19 => 4,
			20 => 4,
			21 => 4,
			22 => 5,
			23 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.transformation_interpolation_start_delta_ticks)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.transformation_interpolation_duration)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.pos_rot_interpolation_duration)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				unimplemented!()
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				unimplemented!()
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				unimplemented!()
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.billboard_render_constraints)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.brightness_override)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.view_range)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.shadow_radius)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.shadow_strength)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.width)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.height)
			},
			22 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.glow_color_override)
			},
			23 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 23);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for BlockDisplayMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
				if indices[22] { size += 2 + self.get_write_size_for_index(22); }
				if indices[23] { size += 2 + self.get_write_size_for_index(23); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
				if indices[22] { bytes = self.write_for_index(bytes, 22); }
				if indices[23] { bytes = self.write_for_index(bytes, 23); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct BoatMetadata {
	changes: MetadataChanges<15>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_type: i32,
	pub id_paddle_left: bool,
	pub id_paddle_right: bool,
	pub id_bubble_time: i32,
}

impl BoatMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_type(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_type = value;
	}
	pub fn set_id_paddle_left(&mut self, value: bool) {
		self.changes.mark_dirty(12);
		self.id_paddle_left = value;
	}
	pub fn set_id_paddle_right(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_paddle_right = value;
	}
	pub fn set_id_bubble_time(&mut self, value: i32) {
		self.changes.mark_dirty(14);
		self.id_bubble_time = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 1,
			13 => 1,
			14 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_type)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_paddle_left)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_paddle_right)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_bubble_time)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for BoatMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct BreezeMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl BreezeMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for BreezeMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CamelMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
	pub dash: bool,
	pub last_pose_change_tick: (),
}

impl CamelMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}
	pub fn set_dash(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.dash = value;
	}
	pub fn set_last_pose_change_tick(&mut self, value: ()) {
		self.changes.mark_dirty(19);
		self.last_pose_change_tick = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			19 => unimplemented!(),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.dash)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CamelMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CatMetadata {
	changes: MetadataChanges<23>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub flags: u8,
	pub owneruuid: Option<u128>,
	pub variant: u8,
	pub is_lying: bool,
	pub relax_state_one: bool,
	pub collar_color: i32,
}

impl CatMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.flags = value;
	}
	pub fn set_owneruuid(&mut self, value: Option<u128>) {
		self.changes.mark_dirty(18);
		self.owneruuid = value;
	}
	pub fn set_variant(&mut self, value: u8) {
		self.changes.mark_dirty(19);
		self.variant = value;
	}
	pub fn set_is_lying(&mut self, value: bool) {
		self.changes.mark_dirty(20);
		self.is_lying = value;
	}
	pub fn set_relax_state_one(&mut self, value: bool) {
		self.changes.mark_dirty(21);
		self.relax_state_one = value;
	}
	pub fn set_collar_color(&mut self, value: i32) {
		self.changes.mark_dirty(22);
		self.collar_color = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1 + if self.owneruuid.is_some() { 16 } else { 0 },
			19 => 1,
			20 => 1,
			21 => 1,
			22 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				unimplemented!()
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				unimplemented!()
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_lying)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.relax_state_one)
			},
			22 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.collar_color)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CatMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
				if indices[22] { size += 2 + self.get_write_size_for_index(22); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
				if indices[22] { bytes = self.write_for_index(bytes, 22); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CaveSpiderMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub flags: u8,
}

impl CaveSpiderMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CaveSpiderMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ChestBoatMetadata {
	changes: MetadataChanges<15>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_type: i32,
	pub id_paddle_left: bool,
	pub id_paddle_right: bool,
	pub id_bubble_time: i32,
}

impl ChestBoatMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_type(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_type = value;
	}
	pub fn set_id_paddle_left(&mut self, value: bool) {
		self.changes.mark_dirty(12);
		self.id_paddle_left = value;
	}
	pub fn set_id_paddle_right(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_paddle_right = value;
	}
	pub fn set_id_bubble_time(&mut self, value: i32) {
		self.changes.mark_dirty(14);
		self.id_bubble_time = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 1,
			13 => 1,
			14 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_type)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_paddle_left)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_paddle_right)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_bubble_time)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ChestBoatMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ChestMinecartMetadata {
	changes: MetadataChanges<14>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
}

impl ChestMinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ChestMinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ChickenMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
}

impl ChickenMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ChickenMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CodMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub from_bucket: bool,
}

impl CodMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_from_bucket(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.from_bucket = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.from_bucket)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CodMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CommandBlockMinecartMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
	pub id_command_name: String,
	pub id_last_output: String,
}

impl CommandBlockMinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}
	pub fn set_id_command_name(&mut self, value: String) {
		self.changes.mark_dirty(14);
		self.id_command_name = value;
	}
	pub fn set_id_last_output(&mut self, value: String) {
		self.changes.mark_dirty(15);
		self.id_last_output = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			14 => 5 + self.id_command_name.len(),
			15 => 5 + self.id_last_output.len(),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				<SizedString<32767> as SliceSerializable<String>>::write(bytes, &self.id_command_name)
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				<SizedString<32767> as SliceSerializable<String>>::write(bytes, &self.id_last_output)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CommandBlockMinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CowMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
}

impl CowMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CowMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct CreeperMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub swell_dir: i32,
	pub is_powered: bool,
	pub is_ignited: bool,
}

impl CreeperMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_swell_dir(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.swell_dir = value;
	}
	pub fn set_is_powered(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.is_powered = value;
	}
	pub fn set_is_ignited(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.is_ignited = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			17 => 1,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.swell_dir)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_powered)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_ignited)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for CreeperMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct DolphinMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub treasure_pos: graphite_mc_protocol::types::BlockPosition,
	pub got_fish: bool,
	pub moistness_level: i32,
}

impl DolphinMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_treasure_pos(&mut self, value: graphite_mc_protocol::types::BlockPosition) {
		self.changes.mark_dirty(16);
		self.treasure_pos = value;
	}
	pub fn set_got_fish(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.got_fish = value;
	}
	pub fn set_moistness_level(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.moistness_level = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 8,
			17 => 1,
			18 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				unimplemented!()
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.got_fish)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.moistness_level)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for DolphinMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct DonkeyMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
	pub id_chest: bool,
}

impl DonkeyMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}
	pub fn set_id_chest(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.id_chest = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_chest)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for DonkeyMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct DragonFireballMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl DragonFireballMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for DragonFireballMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct DrownedMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub special_type: i32,
	pub drowned_conversion: bool,
}

impl DrownedMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_special_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.special_type = value;
	}
	pub fn set_drowned_conversion(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.drowned_conversion = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.special_type)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.drowned_conversion)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for DrownedMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EggMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> EggMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for EggMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ElderGuardianMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub id_moving: bool,
	pub id_attack_target: i32,
}

impl ElderGuardianMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_id_moving(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.id_moving = value;
	}
	pub fn set_id_attack_target(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.id_attack_target = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_moving)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_attack_target)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ElderGuardianMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EndCrystalMetadata {
	changes: MetadataChanges<10>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub beam_target: Option<graphite_mc_protocol::types::BlockPosition>,
	pub show_bottom: bool,
}

impl EndCrystalMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_beam_target(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(8);
		self.beam_target = value;
	}
	pub fn set_show_bottom(&mut self, value: bool) {
		self.changes.mark_dirty(9);
		self.show_bottom = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1 + if self.beam_target.is_some() { 8 } else { 0 },
			9 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.show_bottom)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for EndCrystalMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EnderDragonMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub phase: i32,
}

impl EnderDragonMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_phase(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.phase = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.phase)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for EnderDragonMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EnderPearlMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> EnderPearlMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for EnderPearlMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EndermanMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub carry_state: (),
	pub creepy: bool,
	pub stared_at: bool,
}

impl EndermanMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_carry_state(&mut self, value: ()) {
		self.changes.mark_dirty(16);
		self.carry_state = value;
	}
	pub fn set_creepy(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.creepy = value;
	}
	pub fn set_stared_at(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.stared_at = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => unimplemented!(),
			17 => 1,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				unimplemented!()
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.creepy)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.stared_at)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for EndermanMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EndermiteMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl EndermiteMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for EndermiteMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EvokerMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_celebrating: bool,
	pub spell_casting: u8,
}

impl EvokerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_celebrating(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_celebrating = value;
	}
	pub fn set_spell_casting(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.spell_casting = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_celebrating)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.spell_casting)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for EvokerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EvokerFangsMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl EvokerFangsMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for EvokerFangsMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ExperienceBottleMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> ExperienceBottleMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for ExperienceBottleMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ExperienceOrbMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl ExperienceOrbMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ExperienceOrbMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct EyeOfEnderMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> EyeOfEnderMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for EyeOfEnderMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FallingBlockMetadata {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub start_pos: graphite_mc_protocol::types::BlockPosition,
}

impl FallingBlockMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_start_pos(&mut self, value: graphite_mc_protocol::types::BlockPosition) {
		self.changes.mark_dirty(8);
		self.start_pos = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 8,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for FallingBlockMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FireworkRocketMetadata<'a> {
	changes: MetadataChanges<11>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_fireworks_item: graphite_mc_protocol::types::ProtocolItemStack<'a>,
	pub attached_to_target: Option<u32>,
	pub shot_at_angle: bool,
}

impl<'a> FireworkRocketMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_fireworks_item(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.id_fireworks_item = value;
	}
	pub fn set_attached_to_target(&mut self, value: Option<u32>) {
		self.changes.mark_dirty(9);
		self.attached_to_target = value;
	}
	pub fn set_shot_at_angle(&mut self, value: bool) {
		self.changes.mark_dirty(10);
		self.shot_at_angle = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.id_fireworks_item),
			9 => 5,
			10 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.id_fireworks_item)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				unimplemented!()
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.shot_at_angle)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for FireworkRocketMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FoxMetadata {
	changes: MetadataChanges<21>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub r#type: i32,
	pub flags: u8,
	pub trusted_0: Option<u128>,
	pub trusted_1: Option<u128>,
}

impl FoxMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.r#type = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(18);
		self.flags = value;
	}
	pub fn set_trusted_0(&mut self, value: Option<u128>) {
		self.changes.mark_dirty(19);
		self.trusted_0 = value;
	}
	pub fn set_trusted_1(&mut self, value: Option<u128>) {
		self.changes.mark_dirty(20);
		self.trusted_1 = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			19 => 1 + if self.trusted_0.is_some() { 16 } else { 0 },
			20 => 1 + if self.trusted_1.is_some() { 16 } else { 0 },
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.r#type)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				unimplemented!()
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for FoxMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FrogMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub variant: u8,
	pub tongue_target: Option<u32>,
}

impl FrogMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_variant(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.variant = value;
	}
	pub fn set_tongue_target(&mut self, value: Option<u32>) {
		self.changes.mark_dirty(18);
		self.tongue_target = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				unimplemented!()
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for FrogMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FurnaceMinecartMetadata {
	changes: MetadataChanges<15>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
	pub id_fuel: bool,
}

impl FurnaceMinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}
	pub fn set_id_fuel(&mut self, value: bool) {
		self.changes.mark_dirty(14);
		self.id_fuel = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			14 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_fuel)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for FurnaceMinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct GhastMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_charging: bool,
}

impl GhastMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_charging(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_charging = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_charging)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for GhastMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct GiantMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl GiantMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for GiantMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct GlowItemFrameMetadata<'a> {
	changes: MetadataChanges<10>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item: graphite_mc_protocol::types::ProtocolItemStack<'a>,
	pub rotation: i32,
}

impl<'a> GlowItemFrameMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item = value;
	}
	pub fn set_rotation(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.rotation = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item),
			9 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.rotation)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for GlowItemFrameMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct GlowSquidMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub dark_ticks_remaining: i32,
}

impl GlowSquidMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_dark_ticks_remaining(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.dark_ticks_remaining = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.dark_ticks_remaining)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for GlowSquidMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct GoatMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub is_screaming_goat: bool,
	pub has_left_horn: bool,
	pub has_right_horn: bool,
}

impl GoatMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_is_screaming_goat(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.is_screaming_goat = value;
	}
	pub fn set_has_left_horn(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.has_left_horn = value;
	}
	pub fn set_has_right_horn(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.has_right_horn = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			19 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_screaming_goat)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.has_left_horn)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.has_right_horn)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for GoatMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct GuardianMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub id_moving: bool,
	pub id_attack_target: i32,
}

impl GuardianMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_id_moving(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.id_moving = value;
	}
	pub fn set_id_attack_target(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.id_attack_target = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_moving)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_attack_target)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for GuardianMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct HoglinMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub immune_to_zombification: bool,
}

impl HoglinMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_immune_to_zombification(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.immune_to_zombification = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.immune_to_zombification)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for HoglinMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct HopperMinecartMetadata {
	changes: MetadataChanges<14>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
}

impl HopperMinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for HopperMinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct HorseMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
	pub id_type_variant: i32,
}

impl HorseMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}
	pub fn set_id_type_variant(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.id_type_variant = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_type_variant)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for HorseMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct HuskMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub special_type: i32,
	pub drowned_conversion: bool,
}

impl HuskMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_special_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.special_type = value;
	}
	pub fn set_drowned_conversion(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.drowned_conversion = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.special_type)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.drowned_conversion)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for HuskMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct IllusionerMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_celebrating: bool,
	pub spell_casting: u8,
}

impl IllusionerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_celebrating(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_celebrating = value;
	}
	pub fn set_spell_casting(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.spell_casting = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_celebrating)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.spell_casting)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for IllusionerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct InteractionMetadata {
	changes: MetadataChanges<11>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub width: f32,
	pub height: f32,
	pub response: bool,
}

impl InteractionMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_width(&mut self, value: f32) {
		self.changes.mark_dirty(8);
		self.width = value;
	}
	pub fn set_height(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.height = value;
	}
	pub fn set_response(&mut self, value: bool) {
		self.changes.mark_dirty(10);
		self.response = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 4,
			9 => 4,
			10 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.width)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.height)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.response)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for InteractionMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct IronGolemMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub flags: u8,
}

impl IronGolemMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for IronGolemMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ItemMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> ItemMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for ItemMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ItemDisplayMetadata<'a> {
	changes: MetadataChanges<25>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub transformation_interpolation_start_delta_ticks: i32,
	pub transformation_interpolation_duration: i32,
	pub pos_rot_interpolation_duration: i32,
	pub translation: (),
	pub scale: (),
	pub left_rotation: (),
	pub right_rotation: (),
	pub billboard_render_constraints: u8,
	pub brightness_override: i32,
	pub view_range: f32,
	pub shadow_radius: f32,
	pub shadow_strength: f32,
	pub width: f32,
	pub height: f32,
	pub glow_color_override: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
	pub item_display: u8,
}

impl<'a> ItemDisplayMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_transformation_interpolation_start_delta_ticks(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.transformation_interpolation_start_delta_ticks = value;
	}
	pub fn set_transformation_interpolation_duration(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.transformation_interpolation_duration = value;
	}
	pub fn set_pos_rot_interpolation_duration(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.pos_rot_interpolation_duration = value;
	}
	pub fn set_translation(&mut self, value: ()) {
		self.changes.mark_dirty(11);
		self.translation = value;
	}
	pub fn set_scale(&mut self, value: ()) {
		self.changes.mark_dirty(12);
		self.scale = value;
	}
	pub fn set_left_rotation(&mut self, value: ()) {
		self.changes.mark_dirty(13);
		self.left_rotation = value;
	}
	pub fn set_right_rotation(&mut self, value: ()) {
		self.changes.mark_dirty(14);
		self.right_rotation = value;
	}
	pub fn set_billboard_render_constraints(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.billboard_render_constraints = value;
	}
	pub fn set_brightness_override(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.brightness_override = value;
	}
	pub fn set_view_range(&mut self, value: f32) {
		self.changes.mark_dirty(17);
		self.view_range = value;
	}
	pub fn set_shadow_radius(&mut self, value: f32) {
		self.changes.mark_dirty(18);
		self.shadow_radius = value;
	}
	pub fn set_shadow_strength(&mut self, value: f32) {
		self.changes.mark_dirty(19);
		self.shadow_strength = value;
	}
	pub fn set_width(&mut self, value: f32) {
		self.changes.mark_dirty(20);
		self.width = value;
	}
	pub fn set_height(&mut self, value: f32) {
		self.changes.mark_dirty(21);
		self.height = value;
	}
	pub fn set_glow_color_override(&mut self, value: i32) {
		self.changes.mark_dirty(22);
		self.glow_color_override = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(23);
		self.item_stack = value;
	}
	pub fn set_item_display(&mut self, value: u8) {
		self.changes.mark_dirty(24);
		self.item_display = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 5,
			11 => unimplemented!(),
			12 => unimplemented!(),
			13 => unimplemented!(),
			14 => unimplemented!(),
			15 => 1,
			16 => 5,
			17 => 4,
			18 => 4,
			19 => 4,
			20 => 4,
			21 => 4,
			22 => 5,
			23 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			24 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.transformation_interpolation_start_delta_ticks)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.transformation_interpolation_duration)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.pos_rot_interpolation_duration)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				unimplemented!()
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				unimplemented!()
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				unimplemented!()
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.billboard_render_constraints)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.brightness_override)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.view_range)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.shadow_radius)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.shadow_strength)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.width)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.height)
			},
			22 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.glow_color_override)
			},
			23 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 23);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			24 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 24);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.item_display)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for ItemDisplayMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
				if indices[22] { size += 2 + self.get_write_size_for_index(22); }
				if indices[23] { size += 2 + self.get_write_size_for_index(23); }
				if indices[24] { size += 2 + self.get_write_size_for_index(24); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
				if indices[22] { bytes = self.write_for_index(bytes, 22); }
				if indices[23] { bytes = self.write_for_index(bytes, 23); }
				if indices[24] { bytes = self.write_for_index(bytes, 24); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ItemFrameMetadata<'a> {
	changes: MetadataChanges<10>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item: graphite_mc_protocol::types::ProtocolItemStack<'a>,
	pub rotation: i32,
}

impl<'a> ItemFrameMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item = value;
	}
	pub fn set_rotation(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.rotation = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item),
			9 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.rotation)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for ItemFrameMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FireballMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> FireballMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for FireballMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct LeashKnotMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl LeashKnotMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for LeashKnotMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct LightningBoltMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl LightningBoltMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for LightningBoltMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct LlamaMetadata {
	changes: MetadataChanges<22>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
	pub id_chest: bool,
	pub strength: i32,
	pub swag: i32,
	pub variant: i32,
}

impl LlamaMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}
	pub fn set_id_chest(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.id_chest = value;
	}
	pub fn set_strength(&mut self, value: i32) {
		self.changes.mark_dirty(19);
		self.strength = value;
	}
	pub fn set_swag(&mut self, value: i32) {
		self.changes.mark_dirty(20);
		self.swag = value;
	}
	pub fn set_variant(&mut self, value: i32) {
		self.changes.mark_dirty(21);
		self.variant = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			19 => 5,
			20 => 5,
			21 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_chest)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.strength)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.swag)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.variant)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for LlamaMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct LlamaSpitMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl LlamaSpitMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for LlamaSpitMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct MagmaCubeMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub id_size: i32,
}

impl MagmaCubeMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_id_size(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.id_size = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_size)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for MagmaCubeMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct MarkerMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl MarkerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for MarkerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct MinecartMetadata {
	changes: MetadataChanges<14>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
}

impl MinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for MinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct MooshroomMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub r#type: String,
}

impl MooshroomMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_type(&mut self, value: String) {
		self.changes.mark_dirty(17);
		self.r#type = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5 + self.r#type.len(),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				<SizedString<32767> as SliceSerializable<String>>::write(bytes, &self.r#type)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for MooshroomMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct MuleMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
	pub id_chest: bool,
}

impl MuleMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}
	pub fn set_id_chest(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.id_chest = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_chest)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for MuleMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct OcelotMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub trusting: bool,
}

impl OcelotMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_trusting(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.trusting = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.trusting)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for OcelotMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PaintingMetadata {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub painting_variant: u8,
}

impl PaintingMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_painting_variant(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.painting_variant = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 24);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PaintingMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PandaMetadata {
	changes: MetadataChanges<23>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub unhappy_counter: i32,
	pub sneeze_counter: i32,
	pub eat_counter: i32,
	pub main_gene: u8,
	pub hidden_gene: u8,
	pub id_flags: u8,
}

impl PandaMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_unhappy_counter(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.unhappy_counter = value;
	}
	pub fn set_sneeze_counter(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.sneeze_counter = value;
	}
	pub fn set_eat_counter(&mut self, value: i32) {
		self.changes.mark_dirty(19);
		self.eat_counter = value;
	}
	pub fn set_main_gene(&mut self, value: u8) {
		self.changes.mark_dirty(20);
		self.main_gene = value;
	}
	pub fn set_hidden_gene(&mut self, value: u8) {
		self.changes.mark_dirty(21);
		self.hidden_gene = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(22);
		self.id_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 5,
			19 => 5,
			20 => 1,
			21 => 1,
			22 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.unhappy_counter)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.sneeze_counter)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.eat_counter)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.main_gene)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.hidden_gene)
			},
			22 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PandaMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
				if indices[22] { size += 2 + self.get_write_size_for_index(22); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
				if indices[22] { bytes = self.write_for_index(bytes, 22); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ParrotMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub flags: u8,
	pub owneruuid: Option<u128>,
	pub variant: i32,
}

impl ParrotMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.flags = value;
	}
	pub fn set_owneruuid(&mut self, value: Option<u128>) {
		self.changes.mark_dirty(18);
		self.owneruuid = value;
	}
	pub fn set_variant(&mut self, value: i32) {
		self.changes.mark_dirty(19);
		self.variant = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1 + if self.owneruuid.is_some() { 16 } else { 0 },
			19 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				unimplemented!()
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.variant)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ParrotMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PhantomMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub id_size: i32,
}

impl PhantomMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_id_size(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.id_size = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_size)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PhantomMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PigMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub saddle: bool,
	pub boost_time: i32,
}

impl PigMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_saddle(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.saddle = value;
	}
	pub fn set_boost_time(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.boost_time = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.saddle)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.boost_time)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PigMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PiglinMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub immune_to_zombification: bool,
	pub baby: bool,
	pub is_charging_crossbow: bool,
	pub is_dancing: bool,
}

impl PiglinMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_immune_to_zombification(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.immune_to_zombification = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.baby = value;
	}
	pub fn set_is_charging_crossbow(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.is_charging_crossbow = value;
	}
	pub fn set_is_dancing(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.is_dancing = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			19 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.immune_to_zombification)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_charging_crossbow)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_dancing)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PiglinMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PiglinBruteMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub immune_to_zombification: bool,
}

impl PiglinBruteMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_immune_to_zombification(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.immune_to_zombification = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.immune_to_zombification)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PiglinBruteMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PillagerMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_celebrating: bool,
	pub is_charging_crossbow: bool,
}

impl PillagerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_celebrating(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_celebrating = value;
	}
	pub fn set_is_charging_crossbow(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.is_charging_crossbow = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_celebrating)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_charging_crossbow)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PillagerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PolarBearMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub standing: bool,
}

impl PolarBearMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_standing(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.standing = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.standing)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PolarBearMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PotionMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> PotionMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for PotionMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PufferfishMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub from_bucket: bool,
	pub puff_state: i32,
}

impl PufferfishMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_from_bucket(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.from_bucket = value;
	}
	pub fn set_puff_state(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.puff_state = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.from_bucket)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.puff_state)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PufferfishMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct RabbitMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub r#type: i32,
}

impl RabbitMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.r#type = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.r#type)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for RabbitMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct RavagerMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_celebrating: bool,
}

impl RavagerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_celebrating(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_celebrating = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_celebrating)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for RavagerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SalmonMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub from_bucket: bool,
}

impl SalmonMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_from_bucket(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.from_bucket = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.from_bucket)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SalmonMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SheepMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub wool: u8,
}

impl SheepMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_wool(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.wool = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.wool)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SheepMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ShulkerMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub attach_face: graphite_mc_protocol::types::Direction,
	pub peek: u8,
	pub color: u8,
}

impl ShulkerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_attach_face(&mut self, value: graphite_mc_protocol::types::Direction) {
		self.changes.mark_dirty(16);
		self.attach_face = value;
	}
	pub fn set_peek(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.peek = value;
	}
	pub fn set_color(&mut self, value: u8) {
		self.changes.mark_dirty(18);
		self.color = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				unimplemented!()
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.peek)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.color)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ShulkerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ShulkerBulletMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl ShulkerBulletMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ShulkerBulletMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SilverfishMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl SilverfishMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SilverfishMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SkeletonMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub stray_conversion: bool,
}

impl SkeletonMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_stray_conversion(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.stray_conversion = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.stray_conversion)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SkeletonMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SkeletonHorseMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
}

impl SkeletonHorseMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SkeletonHorseMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SlimeMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub id_size: i32,
}

impl SlimeMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_id_size(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.id_size = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_size)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SlimeMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SmallFireballMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> SmallFireballMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for SmallFireballMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SnifferMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub state: (),
	pub drop_seed_at_tick: i32,
}

impl SnifferMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_state(&mut self, value: ()) {
		self.changes.mark_dirty(17);
		self.state = value;
	}
	pub fn set_drop_seed_at_tick(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.drop_seed_at_tick = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => unimplemented!(),
			18 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 25);
				unimplemented!()
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.drop_seed_at_tick)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SnifferMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SnowGolemMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub pumpkin: u8,
}

impl SnowGolemMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_pumpkin(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.pumpkin = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.pumpkin)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SnowGolemMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SnowballMetadata<'a> {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub item_stack: graphite_mc_protocol::types::ProtocolItemStack<'a>,
}

impl<'a> SnowballMetadata<'a> {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_item_stack(&mut self, value: graphite_mc_protocol::types::ProtocolItemStack<'a>) {
		self.changes.mark_dirty(8);
		self.item_stack = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => graphite_mc_protocol::types::ProtocolItemStack::get_write_size(&self.item_stack),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				graphite_mc_protocol::types::ProtocolItemStack::write(bytes, &self.item_stack)
			},
			_ => unreachable!()
		}
	}
}

impl<'a> Metadata for SnowballMetadata<'a> {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SpawnerMinecartMetadata {
	changes: MetadataChanges<14>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
}

impl SpawnerMinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SpawnerMinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SpectralArrowMetadata {
	changes: MetadataChanges<10>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_flags: u8,
	pub pierce_level: u8,
}

impl SpectralArrowMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.id_flags = value;
	}
	pub fn set_pierce_level(&mut self, value: u8) {
		self.changes.mark_dirty(9);
		self.pierce_level = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.pierce_level)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SpectralArrowMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SpiderMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub flags: u8,
}

impl SpiderMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SpiderMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct SquidMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl SquidMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for SquidMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct StrayMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl StrayMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for StrayMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct StriderMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub boost_time: i32,
	pub suffocating: bool,
	pub saddle: bool,
}

impl StriderMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_boost_time(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.boost_time = value;
	}
	pub fn set_suffocating(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.suffocating = value;
	}
	pub fn set_saddle(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.saddle = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			19 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.boost_time)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.suffocating)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.saddle)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for StriderMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TadpoleMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub from_bucket: bool,
}

impl TadpoleMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_from_bucket(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.from_bucket = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.from_bucket)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TadpoleMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TextDisplayMetadata {
	changes: MetadataChanges<28>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub transformation_interpolation_start_delta_ticks: i32,
	pub transformation_interpolation_duration: i32,
	pub pos_rot_interpolation_duration: i32,
	pub translation: (),
	pub scale: (),
	pub left_rotation: (),
	pub right_rotation: (),
	pub billboard_render_constraints: u8,
	pub brightness_override: i32,
	pub view_range: f32,
	pub shadow_radius: f32,
	pub shadow_strength: f32,
	pub width: f32,
	pub height: f32,
	pub glow_color_override: i32,
	pub text: String,
	pub line_width: i32,
	pub background_color: i32,
	pub text_opacity: u8,
	pub style_flags: u8,
}

impl TextDisplayMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_transformation_interpolation_start_delta_ticks(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.transformation_interpolation_start_delta_ticks = value;
	}
	pub fn set_transformation_interpolation_duration(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.transformation_interpolation_duration = value;
	}
	pub fn set_pos_rot_interpolation_duration(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.pos_rot_interpolation_duration = value;
	}
	pub fn set_translation(&mut self, value: ()) {
		self.changes.mark_dirty(11);
		self.translation = value;
	}
	pub fn set_scale(&mut self, value: ()) {
		self.changes.mark_dirty(12);
		self.scale = value;
	}
	pub fn set_left_rotation(&mut self, value: ()) {
		self.changes.mark_dirty(13);
		self.left_rotation = value;
	}
	pub fn set_right_rotation(&mut self, value: ()) {
		self.changes.mark_dirty(14);
		self.right_rotation = value;
	}
	pub fn set_billboard_render_constraints(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.billboard_render_constraints = value;
	}
	pub fn set_brightness_override(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.brightness_override = value;
	}
	pub fn set_view_range(&mut self, value: f32) {
		self.changes.mark_dirty(17);
		self.view_range = value;
	}
	pub fn set_shadow_radius(&mut self, value: f32) {
		self.changes.mark_dirty(18);
		self.shadow_radius = value;
	}
	pub fn set_shadow_strength(&mut self, value: f32) {
		self.changes.mark_dirty(19);
		self.shadow_strength = value;
	}
	pub fn set_width(&mut self, value: f32) {
		self.changes.mark_dirty(20);
		self.width = value;
	}
	pub fn set_height(&mut self, value: f32) {
		self.changes.mark_dirty(21);
		self.height = value;
	}
	pub fn set_glow_color_override(&mut self, value: i32) {
		self.changes.mark_dirty(22);
		self.glow_color_override = value;
	}
	pub fn set_text(&mut self, value: String) {
		self.changes.mark_dirty(23);
		self.text = value;
	}
	pub fn set_line_width(&mut self, value: i32) {
		self.changes.mark_dirty(24);
		self.line_width = value;
	}
	pub fn set_background_color(&mut self, value: i32) {
		self.changes.mark_dirty(25);
		self.background_color = value;
	}
	pub fn set_text_opacity(&mut self, value: u8) {
		self.changes.mark_dirty(26);
		self.text_opacity = value;
	}
	pub fn set_style_flags(&mut self, value: u8) {
		self.changes.mark_dirty(27);
		self.style_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 5,
			11 => unimplemented!(),
			12 => unimplemented!(),
			13 => unimplemented!(),
			14 => unimplemented!(),
			15 => 1,
			16 => 5,
			17 => 4,
			18 => 4,
			19 => 4,
			20 => 4,
			21 => 4,
			22 => 5,
			23 => 5 + self.text.len(),
			24 => 5,
			25 => 5,
			26 => 1,
			27 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.transformation_interpolation_start_delta_ticks)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.transformation_interpolation_duration)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.pos_rot_interpolation_duration)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				unimplemented!()
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				unimplemented!()
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				unimplemented!()
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.billboard_render_constraints)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.brightness_override)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.view_range)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.shadow_radius)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.shadow_strength)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.width)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.height)
			},
			22 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.glow_color_override)
			},
			23 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 23);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				<SizedString<32767> as SliceSerializable<String>>::write(bytes, &self.text)
			},
			24 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 24);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.line_width)
			},
			25 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 25);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.background_color)
			},
			26 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 26);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.text_opacity)
			},
			27 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 27);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.style_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TextDisplayMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
				if indices[22] { size += 2 + self.get_write_size_for_index(22); }
				if indices[23] { size += 2 + self.get_write_size_for_index(23); }
				if indices[24] { size += 2 + self.get_write_size_for_index(24); }
				if indices[25] { size += 2 + self.get_write_size_for_index(25); }
				if indices[26] { size += 2 + self.get_write_size_for_index(26); }
				if indices[27] { size += 2 + self.get_write_size_for_index(27); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
				if indices[22] { bytes = self.write_for_index(bytes, 22); }
				if indices[23] { bytes = self.write_for_index(bytes, 23); }
				if indices[24] { bytes = self.write_for_index(bytes, 24); }
				if indices[25] { bytes = self.write_for_index(bytes, 25); }
				if indices[26] { bytes = self.write_for_index(bytes, 26); }
				if indices[27] { bytes = self.write_for_index(bytes, 27); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TntMetadata {
	changes: MetadataChanges<10>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub fuse: i32,
	pub block_state: Option<i32>,
}

impl TntMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_fuse(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.fuse = value;
	}
	pub fn set_block_state(&mut self, value: Option<i32>) {
		self.changes.mark_dirty(9);
		self.block_state = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.fuse)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TntMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TntMinecartMetadata {
	changes: MetadataChanges<14>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_hurt: i32,
	pub id_hurtdir: i32,
	pub id_damage: f32,
	pub id_display_block: i32,
	pub id_display_offset: i32,
	pub id_custom_display: bool,
}

impl TntMinecartMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_hurt(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.id_hurt = value;
	}
	pub fn set_id_hurtdir(&mut self, value: i32) {
		self.changes.mark_dirty(9);
		self.id_hurtdir = value;
	}
	pub fn set_id_damage(&mut self, value: f32) {
		self.changes.mark_dirty(10);
		self.id_damage = value;
	}
	pub fn set_id_display_block(&mut self, value: i32) {
		self.changes.mark_dirty(11);
		self.id_display_block = value;
	}
	pub fn set_id_display_offset(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.id_display_offset = value;
	}
	pub fn set_id_custom_display(&mut self, value: bool) {
		self.changes.mark_dirty(13);
		self.id_custom_display = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 5,
			10 => 4,
			11 => 5,
			12 => 5,
			13 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurt)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_hurtdir)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.id_damage)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_block)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_display_offset)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_custom_display)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TntMinecartMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TraderLlamaMetadata {
	changes: MetadataChanges<22>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
	pub id_chest: bool,
	pub strength: i32,
	pub swag: i32,
	pub variant: i32,
}

impl TraderLlamaMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}
	pub fn set_id_chest(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.id_chest = value;
	}
	pub fn set_strength(&mut self, value: i32) {
		self.changes.mark_dirty(19);
		self.strength = value;
	}
	pub fn set_swag(&mut self, value: i32) {
		self.changes.mark_dirty(20);
		self.swag = value;
	}
	pub fn set_variant(&mut self, value: i32) {
		self.changes.mark_dirty(21);
		self.variant = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1,
			19 => 5,
			20 => 5,
			21 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_chest)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.strength)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.swag)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.variant)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TraderLlamaMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TridentMetadata {
	changes: MetadataChanges<12>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub id_flags: u8,
	pub pierce_level: u8,
	pub id_loyalty: u8,
	pub id_foil: bool,
}

impl TridentMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.id_flags = value;
	}
	pub fn set_pierce_level(&mut self, value: u8) {
		self.changes.mark_dirty(9);
		self.pierce_level = value;
	}
	pub fn set_id_loyalty(&mut self, value: u8) {
		self.changes.mark_dirty(10);
		self.id_loyalty = value;
	}
	pub fn set_id_foil(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.id_foil = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 1,
			10 => 1,
			11 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.pierce_level)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_loyalty)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.id_foil)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TridentMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TropicalFishMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub from_bucket: bool,
	pub id_type_variant: i32,
}

impl TropicalFishMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_from_bucket(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.from_bucket = value;
	}
	pub fn set_id_type_variant(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.id_type_variant = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.from_bucket)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_type_variant)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TropicalFishMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct TurtleMetadata {
	changes: MetadataChanges<23>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub home_pos: graphite_mc_protocol::types::BlockPosition,
	pub has_egg: bool,
	pub laying_egg: bool,
	pub travel_pos: graphite_mc_protocol::types::BlockPosition,
	pub going_home: bool,
	pub travelling: bool,
}

impl TurtleMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_home_pos(&mut self, value: graphite_mc_protocol::types::BlockPosition) {
		self.changes.mark_dirty(17);
		self.home_pos = value;
	}
	pub fn set_has_egg(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.has_egg = value;
	}
	pub fn set_laying_egg(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.laying_egg = value;
	}
	pub fn set_travel_pos(&mut self, value: graphite_mc_protocol::types::BlockPosition) {
		self.changes.mark_dirty(20);
		self.travel_pos = value;
	}
	pub fn set_going_home(&mut self, value: bool) {
		self.changes.mark_dirty(21);
		self.going_home = value;
	}
	pub fn set_travelling(&mut self, value: bool) {
		self.changes.mark_dirty(22);
		self.travelling = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 8,
			18 => 1,
			19 => 1,
			20 => 8,
			21 => 1,
			22 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				unimplemented!()
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.has_egg)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.laying_egg)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				unimplemented!()
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.going_home)
			},
			22 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 22);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.travelling)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for TurtleMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
				if indices[22] { size += 2 + self.get_write_size_for_index(22); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
				if indices[22] { bytes = self.write_for_index(bytes, 22); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct VexMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub flags: u8,
}

impl VexMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(16);
		self.flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for VexMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct VillagerMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub unhappy_counter: i32,
	pub villager_data: (u8, u8, i32),
}

impl VillagerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_unhappy_counter(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.unhappy_counter = value;
	}
	pub fn set_villager_data(&mut self, value: (u8, u8, i32)) {
		self.changes.mark_dirty(18);
		self.villager_data = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 7,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.unhappy_counter)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for VillagerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct VindicatorMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_celebrating: bool,
}

impl VindicatorMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_celebrating(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_celebrating = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_celebrating)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for VindicatorMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WanderingTraderMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub unhappy_counter: i32,
}

impl WanderingTraderMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_unhappy_counter(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.unhappy_counter = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.unhappy_counter)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WanderingTraderMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WardenMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub client_anger_level: i32,
}

impl WardenMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_client_anger_level(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.client_anger_level = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.client_anger_level)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WardenMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WindChargeMetadata {
	changes: MetadataChanges<8>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
}

impl WindChargeMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WindChargeMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WitchMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub is_celebrating: bool,
	pub using_item: bool,
}

impl WitchMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_is_celebrating(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.is_celebrating = value;
	}
	pub fn set_using_item(&mut self, value: bool) {
		self.changes.mark_dirty(17);
		self.using_item = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.is_celebrating)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.using_item)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WitchMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WitherMetadata {
	changes: MetadataChanges<20>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub target_a: i32,
	pub target_b: i32,
	pub target_c: i32,
	pub id_inv: i32,
}

impl WitherMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_target_a(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.target_a = value;
	}
	pub fn set_target_b(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.target_b = value;
	}
	pub fn set_target_c(&mut self, value: i32) {
		self.changes.mark_dirty(18);
		self.target_c = value;
	}
	pub fn set_id_inv(&mut self, value: i32) {
		self.changes.mark_dirty(19);
		self.id_inv = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 5,
			17 => 5,
			18 => 5,
			19 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.target_a)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.target_b)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.target_c)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.id_inv)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WitherMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WitherSkeletonMetadata {
	changes: MetadataChanges<16>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
}

impl WitherSkeletonMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WitherSkeletonMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WitherSkullMetadata {
	changes: MetadataChanges<9>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub dangerous: bool,
}

impl WitherSkullMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_dangerous(&mut self, value: bool) {
		self.changes.mark_dirty(8);
		self.dangerous = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.dangerous)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WitherSkullMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct WolfMetadata {
	changes: MetadataChanges<22>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub flags: u8,
	pub owneruuid: Option<u128>,
	pub interested: bool,
	pub collar_color: i32,
	pub remaining_anger_time: i32,
}

impl WolfMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.flags = value;
	}
	pub fn set_owneruuid(&mut self, value: Option<u128>) {
		self.changes.mark_dirty(18);
		self.owneruuid = value;
	}
	pub fn set_interested(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.interested = value;
	}
	pub fn set_collar_color(&mut self, value: i32) {
		self.changes.mark_dirty(20);
		self.collar_color = value;
	}
	pub fn set_remaining_anger_time(&mut self, value: i32) {
		self.changes.mark_dirty(21);
		self.remaining_anger_time = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			18 => 1 + if self.owneruuid.is_some() { 16 } else { 0 },
			19 => 1,
			20 => 5,
			21 => 5,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.flags)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				unimplemented!()
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.interested)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.collar_color)
			},
			21 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 21);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.remaining_anger_time)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for WolfMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
				if indices[21] { size += 2 + self.get_write_size_for_index(21); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
				if indices[21] { bytes = self.write_for_index(bytes, 21); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ZoglinMetadata {
	changes: MetadataChanges<17>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
}

impl ZoglinMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ZoglinMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ZombieMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub special_type: i32,
	pub drowned_conversion: bool,
}

impl ZombieMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_special_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.special_type = value;
	}
	pub fn set_drowned_conversion(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.drowned_conversion = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.special_type)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.drowned_conversion)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ZombieMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ZombieHorseMetadata {
	changes: MetadataChanges<18>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub id_flags: u8,
}

impl ZombieHorseMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_id_flags(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.id_flags = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.id_flags)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ZombieHorseMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ZombieVillagerMetadata {
	changes: MetadataChanges<21>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub special_type: i32,
	pub drowned_conversion: bool,
	pub converting: bool,
	pub villager_data: (u8, u8, i32),
}

impl ZombieVillagerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_special_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.special_type = value;
	}
	pub fn set_drowned_conversion(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.drowned_conversion = value;
	}
	pub fn set_converting(&mut self, value: bool) {
		self.changes.mark_dirty(19);
		self.converting = value;
	}
	pub fn set_villager_data(&mut self, value: (u8, u8, i32)) {
		self.changes.mark_dirty(20);
		self.villager_data = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			19 => 1,
			20 => 7,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.special_type)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.drowned_conversion)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.converting)
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ZombieVillagerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct ZombifiedPiglinMetadata {
	changes: MetadataChanges<19>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub mob_flags: u8,
	pub baby: bool,
	pub special_type: i32,
	pub drowned_conversion: bool,
}

impl ZombifiedPiglinMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_mob_flags(&mut self, value: u8) {
		self.changes.mark_dirty(15);
		self.mob_flags = value;
	}
	pub fn set_baby(&mut self, value: bool) {
		self.changes.mark_dirty(16);
		self.baby = value;
	}
	pub fn set_special_type(&mut self, value: i32) {
		self.changes.mark_dirty(17);
		self.special_type = value;
	}
	pub fn set_drowned_conversion(&mut self, value: bool) {
		self.changes.mark_dirty(18);
		self.drowned_conversion = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 1,
			16 => 1,
			17 => 5,
			18 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.mob_flags)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.baby)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.special_type)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.drowned_conversion)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for ZombifiedPiglinMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct PlayerMetadata {
	changes: MetadataChanges<21>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub living_entity_flags: u8,
	pub health: f32,
	pub effect_color: i32,
	pub effect_ambience: bool,
	pub arrow_count: i32,
	pub stinger_count: i32,
	pub sleeping_pos: Option<graphite_mc_protocol::types::BlockPosition>,
	pub player_absorption: f32,
	pub score: i32,
	pub player_mode_customisation: u8,
	pub player_main_hand: u8,
	pub shoulder_left: (),
	pub shoulder_right: (),
}

impl PlayerMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_living_entity_flags(&mut self, value: u8) {
		self.changes.mark_dirty(8);
		self.living_entity_flags = value;
	}
	pub fn set_health(&mut self, value: f32) {
		self.changes.mark_dirty(9);
		self.health = value;
	}
	pub fn set_effect_color(&mut self, value: i32) {
		self.changes.mark_dirty(10);
		self.effect_color = value;
	}
	pub fn set_effect_ambience(&mut self, value: bool) {
		self.changes.mark_dirty(11);
		self.effect_ambience = value;
	}
	pub fn set_arrow_count(&mut self, value: i32) {
		self.changes.mark_dirty(12);
		self.arrow_count = value;
	}
	pub fn set_stinger_count(&mut self, value: i32) {
		self.changes.mark_dirty(13);
		self.stinger_count = value;
	}
	pub fn set_sleeping_pos(&mut self, value: Option<graphite_mc_protocol::types::BlockPosition>) {
		self.changes.mark_dirty(14);
		self.sleeping_pos = value;
	}
	pub fn set_player_absorption(&mut self, value: f32) {
		self.changes.mark_dirty(15);
		self.player_absorption = value;
	}
	pub fn set_score(&mut self, value: i32) {
		self.changes.mark_dirty(16);
		self.score = value;
	}
	pub fn set_player_mode_customisation(&mut self, value: u8) {
		self.changes.mark_dirty(17);
		self.player_mode_customisation = value;
	}
	pub fn set_player_main_hand(&mut self, value: u8) {
		self.changes.mark_dirty(18);
		self.player_main_hand = value;
	}
	pub fn set_shoulder_left(&mut self, value: ()) {
		self.changes.mark_dirty(19);
		self.shoulder_left = value;
	}
	pub fn set_shoulder_right(&mut self, value: ()) {
		self.changes.mark_dirty(20);
		self.shoulder_right = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 1,
			9 => 4,
			10 => 5,
			11 => 1,
			12 => 5,
			13 => 5,
			14 => 1 + if self.sleeping_pos.is_some() { 8 } else { 0 },
			15 => 4,
			16 => 5,
			17 => 1,
			18 => 1,
			19 => unimplemented!(),
			20 => unimplemented!(),
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.living_entity_flags)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.health)
			},
			10 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 10);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.effect_color)
			},
			11 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.effect_ambience)
			},
			12 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 12);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.arrow_count)
			},
			13 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 13);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.stinger_count)
			},
			14 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 14);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 11);
				unimplemented!()
			},
			15 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 15);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				<BigEndian as SliceSerializable<f32>>::write(bytes, self.player_absorption)
			},
			16 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.score)
			},
			17 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 17);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.player_mode_customisation)
			},
			18 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 18);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.player_main_hand)
			},
			19 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 19);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				unimplemented!()
			},
			20 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 16);
				unimplemented!()
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for PlayerMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
				if indices[10] { size += 2 + self.get_write_size_for_index(10); }
				if indices[11] { size += 2 + self.get_write_size_for_index(11); }
				if indices[12] { size += 2 + self.get_write_size_for_index(12); }
				if indices[13] { size += 2 + self.get_write_size_for_index(13); }
				if indices[14] { size += 2 + self.get_write_size_for_index(14); }
				if indices[15] { size += 2 + self.get_write_size_for_index(15); }
				if indices[16] { size += 2 + self.get_write_size_for_index(16); }
				if indices[17] { size += 2 + self.get_write_size_for_index(17); }
				if indices[18] { size += 2 + self.get_write_size_for_index(18); }
				if indices[19] { size += 2 + self.get_write_size_for_index(19); }
				if indices[20] { size += 2 + self.get_write_size_for_index(20); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
				if indices[10] { bytes = self.write_for_index(bytes, 10); }
				if indices[11] { bytes = self.write_for_index(bytes, 11); }
				if indices[12] { bytes = self.write_for_index(bytes, 12); }
				if indices[13] { bytes = self.write_for_index(bytes, 13); }
				if indices[14] { bytes = self.write_for_index(bytes, 14); }
				if indices[15] { bytes = self.write_for_index(bytes, 15); }
				if indices[16] { bytes = self.write_for_index(bytes, 16); }
				if indices[17] { bytes = self.write_for_index(bytes, 17); }
				if indices[18] { bytes = self.write_for_index(bytes, 18); }
				if indices[19] { bytes = self.write_for_index(bytes, 19); }
				if indices[20] { bytes = self.write_for_index(bytes, 20); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

#[readonly::make]
#[derive(Default)]
pub struct FishingBobberMetadata {
	changes: MetadataChanges<10>,
	pub shared_flags: u8,
	pub air_supply: i32,
	pub custom_name: Option<String>,
	pub custom_name_visible: bool,
	pub silent: bool,
	pub no_gravity: bool,
	pub pose: graphite_mc_protocol::types::Pose,
	pub ticks_frozen: i32,
	pub hooked_entity: i32,
	pub biting: bool,
}

impl FishingBobberMetadata {
	pub fn set_shared_flags(&mut self, value: u8) {
		self.changes.mark_dirty(0);
		self.shared_flags = value;
	}
	pub fn set_air_supply(&mut self, value: i32) {
		self.changes.mark_dirty(1);
		self.air_supply = value;
	}
	pub fn set_custom_name(&mut self, value: Option<String>) {
		self.changes.mark_dirty(2);
		self.custom_name = value;
	}
	pub fn set_custom_name_visible(&mut self, value: bool) {
		self.changes.mark_dirty(3);
		self.custom_name_visible = value;
	}
	pub fn set_silent(&mut self, value: bool) {
		self.changes.mark_dirty(4);
		self.silent = value;
	}
	pub fn set_no_gravity(&mut self, value: bool) {
		self.changes.mark_dirty(5);
		self.no_gravity = value;
	}
	pub fn set_pose(&mut self, value: graphite_mc_protocol::types::Pose) {
		self.changes.mark_dirty(6);
		self.pose = value;
	}
	pub fn set_ticks_frozen(&mut self, value: i32) {
		self.changes.mark_dirty(7);
		self.ticks_frozen = value;
	}
	pub fn set_hooked_entity(&mut self, value: i32) {
		self.changes.mark_dirty(8);
		self.hooked_entity = value;
	}
	pub fn set_biting(&mut self, value: bool) {
		self.changes.mark_dirty(9);
		self.biting = value;
	}

	#[inline(always)]
	pub fn get_write_size_for_index(&self, index: usize) -> usize {
		match index {
			0 => 1,
			1 => 5,
			2 => 1 + if let Some(value) = &self.custom_name { 5 + value.len() } else { 0 },
			3 => 1,
			4 => 1,
			5 => 1,
			6 => 1,
			7 => 5,
			8 => 5,
			9 => 1,
			_ => unreachable!()
		}
	}

	#[inline(always)]
	pub unsafe fn write_for_index<'b>(&self, mut bytes: &'b mut [u8], index: usize) -> &'b mut [u8] {
		match index {
			0 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 0);
				<Single as SliceSerializable<u8>>::write(bytes, self.shared_flags)
			},
			1 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.air_supply)
			},
			2 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 2);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				<Option<SizedString<32767>> as SliceSerializable<_>>::write(bytes, &self.custom_name)
			},
			3 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 3);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.custom_name_visible)
			},
			4 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 4);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.silent)
			},
			5 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 5);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.no_gravity)
			},
			6 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 6);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 20);
				<Single as SliceSerializable<u8>>::write(bytes, self.pose as u8)
			},
			7 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 7);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.ticks_frozen)
			},
			8 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 1);
				<VarInt as SliceSerializable<i32>>::write(bytes, self.hooked_entity)
			},
			9 => {
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 9);
				bytes = <Single as SliceSerializable<u8>>::write(bytes, 8);
				<Single as SliceSerializable<bool>>::write(bytes, self.biting)
			},
			_ => unreachable!()
		}
	}
}

impl Metadata for FishingBobberMetadata {
    /*fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
        self
    }*/

    fn read_changes(&mut self, _bytes: &mut &[u8]) -> std::result::Result<(), InvalidMetadataChanges> {
        unimplemented!();
    }

    fn get_write_size(&self) -> usize {
        match self.changes {
            MetadataChanges::NoChanges => 0,
            MetadataChanges::SingleChange { index } => {
                1 + 2 + self.get_write_size_for_index(index)
            },
            MetadataChanges::ManyChanges { indices } => {
                let mut size = 1;
				if indices[0] { size += 2 + self.get_write_size_for_index(0); }
				if indices[1] { size += 2 + self.get_write_size_for_index(1); }
				if indices[2] { size += 2 + self.get_write_size_for_index(2); }
				if indices[3] { size += 2 + self.get_write_size_for_index(3); }
				if indices[4] { size += 2 + self.get_write_size_for_index(4); }
				if indices[5] { size += 2 + self.get_write_size_for_index(5); }
				if indices[6] { size += 2 + self.get_write_size_for_index(6); }
				if indices[7] { size += 2 + self.get_write_size_for_index(7); }
				if indices[8] { size += 2 + self.get_write_size_for_index(8); }
				if indices[9] { size += 2 + self.get_write_size_for_index(9); }
                size
            }
        }
    }

    unsafe fn write_changes<'b>(&mut self, mut bytes: &'b mut [u8]) -> &'b mut [u8] {
        match self.changes {
            MetadataChanges::NoChanges => {},
            MetadataChanges::SingleChange { index } => {
                bytes = self.write_for_index(bytes, index);
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            },
            MetadataChanges::ManyChanges { indices } => {
				if indices[0] { bytes = self.write_for_index(bytes, 0); }
				if indices[1] { bytes = self.write_for_index(bytes, 1); }
				if indices[2] { bytes = self.write_for_index(bytes, 2); }
				if indices[3] { bytes = self.write_for_index(bytes, 3); }
				if indices[4] { bytes = self.write_for_index(bytes, 4); }
				if indices[5] { bytes = self.write_for_index(bytes, 5); }
				if indices[6] { bytes = self.write_for_index(bytes, 6); }
				if indices[7] { bytes = self.write_for_index(bytes, 7); }
				if indices[8] { bytes = self.write_for_index(bytes, 8); }
				if indices[9] { bytes = self.write_for_index(bytes, 9); }
                bytes = <Single as SliceSerializable<u8>>::write(bytes, 255);
            }
        }
        self.changes = MetadataChanges::NoChanges;
        bytes
    }
}

impl Entity {
    pub fn get_properties(self) -> &'static EntityProperties {
        &ENTITY_PROPERTIES_LUT[self as usize]
    }
}

#[derive(Debug)]
pub struct EntityProperties {
	pub width: f32,
	pub height: f32,
}

const ENTITY_PROPERTIES_LUT: [EntityProperties; 126] = [
	EntityProperties { // allay
		width: 0.35_f32,
		height: 0.6_f32,
	},
	EntityProperties { // area_effect_cloud
		width: 6_f32,
		height: 0.5_f32,
	},
	EntityProperties { // armor_stand
		width: 0.5_f32,
		height: 1.975_f32,
	},
	EntityProperties { // arrow
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // axolotl
		width: 0.75_f32,
		height: 0.42_f32,
	},
	EntityProperties { // bat
		width: 0.5_f32,
		height: 0.9_f32,
	},
	EntityProperties { // bee
		width: 0.7_f32,
		height: 0.6_f32,
	},
	EntityProperties { // blaze
		width: 0.6_f32,
		height: 1.8_f32,
	},
	EntityProperties { // block_display
		width: 0_f32,
		height: 0_f32,
	},
	EntityProperties { // boat
		width: 1.375_f32,
		height: 0.5625_f32,
	},
	EntityProperties { // breeze
		width: 0.6_f32,
		height: 1.7_f32,
	},
	EntityProperties { // camel
		width: 1.7_f32,
		height: 2.375_f32,
	},
	EntityProperties { // cat
		width: 0.6_f32,
		height: 0.7_f32,
	},
	EntityProperties { // cave_spider
		width: 0.7_f32,
		height: 0.5_f32,
	},
	EntityProperties { // chest_boat
		width: 1.375_f32,
		height: 0.5625_f32,
	},
	EntityProperties { // chest_minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // chicken
		width: 0.4_f32,
		height: 0.7_f32,
	},
	EntityProperties { // cod
		width: 0.5_f32,
		height: 0.3_f32,
	},
	EntityProperties { // command_block_minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // cow
		width: 0.9_f32,
		height: 1.4_f32,
	},
	EntityProperties { // creeper
		width: 0.6_f32,
		height: 1.7_f32,
	},
	EntityProperties { // dolphin
		width: 0.9_f32,
		height: 0.6_f32,
	},
	EntityProperties { // donkey
		width: 1.3964844_f32,
		height: 1.5_f32,
	},
	EntityProperties { // dragon_fireball
		width: 1_f32,
		height: 1_f32,
	},
	EntityProperties { // drowned
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // egg
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // elder_guardian
		width: 1.9975_f32,
		height: 1.9975_f32,
	},
	EntityProperties { // end_crystal
		width: 2_f32,
		height: 2_f32,
	},
	EntityProperties { // ender_dragon
		width: 16_f32,
		height: 8_f32,
	},
	EntityProperties { // ender_pearl
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // enderman
		width: 0.6_f32,
		height: 2.9_f32,
	},
	EntityProperties { // endermite
		width: 0.4_f32,
		height: 0.3_f32,
	},
	EntityProperties { // evoker
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // evoker_fangs
		width: 0.5_f32,
		height: 0.8_f32,
	},
	EntityProperties { // experience_bottle
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // experience_orb
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // eye_of_ender
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // falling_block
		width: 0.98_f32,
		height: 0.98_f32,
	},
	EntityProperties { // firework_rocket
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // fox
		width: 0.6_f32,
		height: 0.7_f32,
	},
	EntityProperties { // frog
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // furnace_minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // ghast
		width: 4_f32,
		height: 4_f32,
	},
	EntityProperties { // giant
		width: 3.6_f32,
		height: 12_f32,
	},
	EntityProperties { // glow_item_frame
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // glow_squid
		width: 0.8_f32,
		height: 0.8_f32,
	},
	EntityProperties { // goat
		width: 0.9_f32,
		height: 1.3_f32,
	},
	EntityProperties { // guardian
		width: 0.85_f32,
		height: 0.85_f32,
	},
	EntityProperties { // hoglin
		width: 1.3964844_f32,
		height: 1.4_f32,
	},
	EntityProperties { // hopper_minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // horse
		width: 1.3964844_f32,
		height: 1.6_f32,
	},
	EntityProperties { // husk
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // illusioner
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // interaction
		width: 0_f32,
		height: 0_f32,
	},
	EntityProperties { // iron_golem
		width: 1.4_f32,
		height: 2.7_f32,
	},
	EntityProperties { // item
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // item_display
		width: 0_f32,
		height: 0_f32,
	},
	EntityProperties { // item_frame
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // fireball
		width: 1_f32,
		height: 1_f32,
	},
	EntityProperties { // leash_knot
		width: 0.375_f32,
		height: 0.5_f32,
	},
	EntityProperties { // lightning_bolt
		width: 0_f32,
		height: 0_f32,
	},
	EntityProperties { // llama
		width: 0.9_f32,
		height: 1.87_f32,
	},
	EntityProperties { // llama_spit
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // magma_cube
		width: 2.04_f32,
		height: 2.04_f32,
	},
	EntityProperties { // marker
		width: 0_f32,
		height: 0_f32,
	},
	EntityProperties { // minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // mooshroom
		width: 0.9_f32,
		height: 1.4_f32,
	},
	EntityProperties { // mule
		width: 1.3964844_f32,
		height: 1.6_f32,
	},
	EntityProperties { // ocelot
		width: 0.6_f32,
		height: 0.7_f32,
	},
	EntityProperties { // painting
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // panda
		width: 1.3_f32,
		height: 1.25_f32,
	},
	EntityProperties { // parrot
		width: 0.5_f32,
		height: 0.9_f32,
	},
	EntityProperties { // phantom
		width: 0.9_f32,
		height: 0.5_f32,
	},
	EntityProperties { // pig
		width: 0.9_f32,
		height: 0.9_f32,
	},
	EntityProperties { // piglin
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // piglin_brute
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // pillager
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // polar_bear
		width: 1.4_f32,
		height: 1.4_f32,
	},
	EntityProperties { // potion
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // pufferfish
		width: 0.7_f32,
		height: 0.7_f32,
	},
	EntityProperties { // rabbit
		width: 0.4_f32,
		height: 0.5_f32,
	},
	EntityProperties { // ravager
		width: 1.95_f32,
		height: 2.2_f32,
	},
	EntityProperties { // salmon
		width: 0.7_f32,
		height: 0.4_f32,
	},
	EntityProperties { // sheep
		width: 0.9_f32,
		height: 1.3_f32,
	},
	EntityProperties { // shulker
		width: 1_f32,
		height: 1_f32,
	},
	EntityProperties { // shulker_bullet
		width: 0.3125_f32,
		height: 0.3125_f32,
	},
	EntityProperties { // silverfish
		width: 0.4_f32,
		height: 0.3_f32,
	},
	EntityProperties { // skeleton
		width: 0.6_f32,
		height: 1.99_f32,
	},
	EntityProperties { // skeleton_horse
		width: 1.3964844_f32,
		height: 1.6_f32,
	},
	EntityProperties { // slime
		width: 2.04_f32,
		height: 2.04_f32,
	},
	EntityProperties { // small_fireball
		width: 0.3125_f32,
		height: 0.3125_f32,
	},
	EntityProperties { // sniffer
		width: 1.9_f32,
		height: 1.75_f32,
	},
	EntityProperties { // snow_golem
		width: 0.7_f32,
		height: 1.9_f32,
	},
	EntityProperties { // snowball
		width: 0.25_f32,
		height: 0.25_f32,
	},
	EntityProperties { // spawner_minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // spectral_arrow
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // spider
		width: 1.4_f32,
		height: 0.9_f32,
	},
	EntityProperties { // squid
		width: 0.8_f32,
		height: 0.8_f32,
	},
	EntityProperties { // stray
		width: 0.6_f32,
		height: 1.99_f32,
	},
	EntityProperties { // strider
		width: 0.9_f32,
		height: 1.7_f32,
	},
	EntityProperties { // tadpole
		width: 0.4_f32,
		height: 0.3_f32,
	},
	EntityProperties { // text_display
		width: 0_f32,
		height: 0_f32,
	},
	EntityProperties { // tnt
		width: 0.98_f32,
		height: 0.98_f32,
	},
	EntityProperties { // tnt_minecart
		width: 0.98_f32,
		height: 0.7_f32,
	},
	EntityProperties { // trader_llama
		width: 0.9_f32,
		height: 1.87_f32,
	},
	EntityProperties { // trident
		width: 0.5_f32,
		height: 0.5_f32,
	},
	EntityProperties { // tropical_fish
		width: 0.5_f32,
		height: 0.4_f32,
	},
	EntityProperties { // turtle
		width: 1.2_f32,
		height: 0.4_f32,
	},
	EntityProperties { // vex
		width: 0.4_f32,
		height: 0.8_f32,
	},
	EntityProperties { // villager
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // vindicator
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // wandering_trader
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // warden
		width: 0.9_f32,
		height: 2.9_f32,
	},
	EntityProperties { // wind_charge
		width: 0.3125_f32,
		height: 0.3125_f32,
	},
	EntityProperties { // witch
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // wither
		width: 0.9_f32,
		height: 3.5_f32,
	},
	EntityProperties { // wither_skeleton
		width: 0.7_f32,
		height: 2.4_f32,
	},
	EntityProperties { // wither_skull
		width: 0.3125_f32,
		height: 0.3125_f32,
	},
	EntityProperties { // wolf
		width: 0.6_f32,
		height: 0.85_f32,
	},
	EntityProperties { // zoglin
		width: 1.3964844_f32,
		height: 1.4_f32,
	},
	EntityProperties { // zombie
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // zombie_horse
		width: 1.3964844_f32,
		height: 1.6_f32,
	},
	EntityProperties { // zombie_villager
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // zombified_piglin
		width: 0.6_f32,
		height: 1.95_f32,
	},
	EntityProperties { // player
		width: 0.6_f32,
		height: 1.8_f32,
	},
	EntityProperties { // fishing_bobber
		width: 0.25_f32,
		height: 0.25_f32,
	},
];

#[derive(Debug, thiserror::Error)]
#[error("No entity exists for id: {0}")]
pub struct NoSuchEntityError(u8);

impl TryFrom<u8> for Entity {
	type Error = NoSuchEntityError;
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		if value >= 126 { return Err(NoSuchEntityError(value)); }
		Ok(unsafe { std::mem::transmute(value) })
	}
}